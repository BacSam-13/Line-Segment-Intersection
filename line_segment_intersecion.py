# -*- coding: utf-8 -*-
"""Line Segment Intersecion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14I9s0BJtpvF4ybq0VTpdiFzeiZUZheh_

Autor: Baruc Samuel Cabrera García

# **Line Segment Intersection**

Se realizara una implementación del algoritmo Line Segment Intersection con una sweepline

# Librerias necesarias
"""

from collections import deque
import matplotlib.pyplot as plt
import random
import queue
import numpy as np
import copy

"""# RBT
Para emplear el algoritmo, es recomendable usar un RBT.
Se usara la siguiente implementación ya establecida, la cual se adaptara a las clases de datos que se declararan mas adelante al sobrecargar los operadores.
La versión original se encuentra en el sigueinte link pero se realizaron modificaciones para adaptarse al problema en cuestión:
https://favtutor.com/blogs/red-black-tree-python

"""

# Deinimos al nodo
class Node():
    def __init__(self,val):
        self.val = val # Valor del nodo
        self.parent = None # Padre
        self.left = None # Hijo izquierdo
        self.right = None # Hijo derecho
        self.color = "Red" # Color base de nodo

    def print(self):
        self.val.print()

# Definimos un RBTree
class RBTree():
    def __init__(self):
        self.NULL = Node ( None )
        self.NULL.color = "Black"
        self.NULL.left = None
        self.NULL.right = None
        self.root = self.NULL

    def search(self, key):
        #print("Se inicio search:")
        return self._search_recursion(self.root, key)

    def _search_recursion(self, node, key): # Funcion recursiva que busca la llave "key" en el subarbol node
        if node == self.NULL or node.val == key: # Si llegamos a un final o encontramos al nodo
          return node
        if key < node.val: # Si seguimos buscando en el subarbol izquierdo
            #print("<----")
            return self._search_recursion(node.left, key)
        #print("---->")
        return self._search_recursion(node.right, key) # Si seguimos buscando en el subarbol derecho

    # Insertar nodo
    def insert(self, key):
        node = Node(key)
        node.parent = None
        node.val = key
        node.left = self.NULL
        node.right = self.NULL
        node.color = "Red"

        y = None
        x = self.root

        while x != self.NULL : # Buscamos la posicion para el nuevo nodo
            y = x
            #node.val.print()
            #x.val.print()
            if node.val < x.val :
                x = x.left
            else :
                x = x.right

        node.parent = y # El padre del nodo sera y
        if y == None : # Si estamos en la raiz
            self.root = node
        elif node.val < y.val : # Determinamos si el nodo es hijo derecho o izquierdo
            y.left = node
        else :
            y.right = node

        if node.parent == None : # Root node is always Black
            node.color = "Black"
            return

        if node.parent.parent == None : # If parent of node is Root Node
            return

        self.fixInsert ( node ) # Else call for Fix Up


    def minimum(self, node): # Regresa el minimo del subarbol node
        while node.left != self.NULL:
            node = node.left
        return node


    def vecino_derecho_idx(self, id): # Obtenemos el indice del vecino derecho del nodo con "val"

      inorder = self.inorder_transversal_keys()
      ids_inorder = [] # Obtenemos los indices de los segmentos inorder
      for s in inorder:
        ids_inorder.append(s.id)

      idx = ids_inorder.index(id) # Tomamos la posicion donde esta id
      if idx + 1 < len(ids_inorder):
        return idx + 1
      return -1

    def maximum(self, node): # Obtiene el nodo maximo del subarbol node
        while node.right != self.NULL:
            node = node.right
        return node

    def vecino_izquierdo_idx(self, id): # Obtenemos el indice del vecino izquierdo del nodo con id

      inorder = self.inorder_transversal_keys()
      ids_inorder = [] # Obtenemos los indices de los segmentos inorder
      for s in inorder:
        ids_inorder.append(s.id)

      idx = ids_inorder.index(id) # Tomamos la posicion donde esta id
      if idx - 1 >= 0:
        return idx - 1
      return -1

    def pop_minimum(self):
        node = self.minimum(self.root)
        self.delete_node(node.val)
        return node

    # Rotacion izquierda
    def LR ( self , x ) :
        y = x.right
        x.right = y.left
        if y.left != self.NULL :
            y.left.parent = x

        y.parent = x.parent
        if x.parent == None :
            self.root = y
        elif x == x.parent.left :
            x.parent.left = y
        else :
            x.parent.right = y
        y.left = x
        x.parent = y


    # Rotacion derecha
    def RR ( self , x ) :
        y = x.left
        x.left = y.right
        if y.right != self.NULL :
            y.right.parent = x

        y.parent = x.parent
        if x.parent == None :
            self.root = y
        elif x == x.parent.right :
            x.parent.right = y
        else :
            x.parent.left = y
        y.right = x
        x.parent = y


    # Arreglar una insercion
    def fixInsert(self, k):
        while k.parent.color == "Red":
            if k.parent == k.parent.parent.right:
                u = k.parent.parent.left
                if u.color == "Red":
                    u.color = "Black"
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    k = k.parent.parent
                else:
                    if k == k.parent.left:
                        k = k.parent
                        self.RR(k)
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    self.LR(k.parent.parent)
            else:
                u = k.parent.parent.right
                if u.color == "Red":
                    u.color = "Black"
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    k = k.parent.parent
                else:
                    if k == k.parent.right:
                        k = k.parent
                        self.LR(k)
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    self.RR(k.parent.parent)
            if k == self.root:
                break
        self.root.color = "Black"



    # Arreglar una eliminacion
    def fixDelete(self, x):
        while x != self.root and x.color == "Black":
            if x == x.parent.left:
                s = x.parent.right
                if s.color == "Red":
                    s.color = "Black"
                    x.parent.color = "Red"
                    self.LR(x.parent)
                    s = x.parent.right

                if s.left.color == "Black" and s.right.color == "Black":
                    s.color = "Red"
                    x = x.parent
                else:
                    if s.right.color == "Black":
                        s.left.color = "Black"
                        s.color = "Red"
                        self.RR(s)
                        s = x.parent.right

                    s.color = x.parent.color
                    x.parent.color = "Black"
                    s.right.color = "Black"
                    self.LR(x.parent)
                    x = self.root
            else:
                s = x.parent.left
                if s.color == "Red":
                    s.color = "Black"
                    x.parent.color = "Red"
                    self.RR(x.parent)
                    s = x.parent.left

                if s.right.color == "Black" and s.right.color == "Black":
                    s.color = "Red"
                    x = x.parent
                else:
                    if s.left.color == "Black":
                        s.right.color = "Black"
                        s.color = "Red"
                        self.LR(s)
                        s = x.parent.left

                    s.color = x.parent.color
                    x.parent.color = "Black"
                    s.left.color = "Black"
                    self.RR(x.parent)
                    x = self.root
        x.color = "Black"



    # Transplantar nodos
    def __rb_transplant ( self , u , v ) :
        if u.parent == None :
            self.root = v
        elif u == u.parent.left :
            u.parent.left = v
        else :
            u.parent.right = v
        v.parent = u.parent


    # Funcion recursiva para eliminar nodo
    def delete_node_helper ( self , node , key ) :
        z = self.NULL
        while node != self.NULL :
            #node.val.print()
            #print("//////////")
            if node.val == key :
                z = node

            if key < node.val :
                node = node.left
            else :
                node = node.right

        if z == self.NULL :
            #print ( "No se encontro el valor" )
            return

        y = z
        y_original_color = y.color
        if z.left == self.NULL :
            x = z.right
            self.__rb_transplant ( z , z.right )
        elif (z.right == self.NULL) :
            x = z.left
            self.__rb_transplant ( z , z.left )
        else :
            y = self.minimum ( z.right )
            y_original_color = y.color
            x = y.right
            if y.parent == z :
                x.parent = y
            else :
                self.__rb_transplant ( y , y.right )
                y.right = z.right
                y.right.parent = y

            self.__rb_transplant ( z , y )
            y.left = z.left
            y.left.parent = y
            y.color = z.color
        if y_original_color == "Black" :
            self.fixDelete ( x )


    # Borramos el nodo con el valor "val"
    def delete_node ( self , val ) :
        self.delete_node_helper ( self.root , val )

    # Genera un arreglo con los nodos in order
    def inorder_tranversal(self):
        nodes = []
        self._inorder_traversal_recursive(self.root, nodes)
        return nodes

    # Funcion auxiliar recursiva
    def _inorder_traversal_recursive(self, node, nodes):
        if node != self.NULL:
            self._inorder_traversal_recursive(node.left, nodes)
            nodes.append(node)
            self._inorder_traversal_recursive(node.right, nodes)

    # Obtiene el inorden del arbol pero solo regresa las keys
    def inorder_transversal_keys(self):

        nodes = self.inorder_tranversal() # Obtenemos los nodos actuales

        # Obtenemos unicamente los segmentos
        segmentos_actuales= []
        for n in nodes:
          segmentos_actuales.append(n.val)

        return segmentos_actuales

    def inorder_transversal_ids(self):
        keys = self.inorder_transversal_keys()

        ids = []
        for k in keys:
          ids.append(k.val.id)
        return ids

    def state(self):
      data = self.inorder_transversal_keys()
      for d in data:
        d.print()
        print("-------")
      print("--------------")
    def is_empty(self):
        if self.root == self.NULL:
            return True

    # Function to print
    def __printCall ( self , node , indent , last ) :
        if node != self.NULL :
            print(indent, end=' ')
            if last :
                print ("R----",end= ' ')
                indent += "     "
            else :
                print("L----",end=' ')
                indent += "|    "

            s_color = "RED" if node.color == 1 else "BLACK"
            print ( str ( node.val ) + "(" + s_color + ")" )
            self.__printCall ( node.left , indent , False )
            self.__printCall ( node.right , indent , True )

    # Function to call print
    def print_tree ( self ) :
        self.__printCall ( self.root , "" , True )

"""# Clases de datos
Declararemos las clases de datos que utilizaremos, los cuales son puntos y segmentos, ademas de sobrecargar los operadores <,>,= para estos, y declarar funciones que trabajen con tales clases para fines del algoritmo

"""

from re import X
height_sweepline = np.inf

# Segmentos
class Segment:
  def __init__(self, up, low, id): # Punto superior, punto inferior, id del segmento, altura de la sweepline (debe ser igual a la de uno de sus extremos)
    # Organizamos los puntos para que el mas alto (menor) sea up
    if up < low:
      self.up = up # Punto superior
      self.low = low # Punto inferior
    else:
      self.up = low # Punto superior
      self.low = up # Punto inferior

    self.id = id # Id del segmento

  def print(self):
    print("Puntos up y low:")
    self.up.print()
    self.low.print()
    print(f"Id: {self.id}")

  # Especifica si un punto se encuentra entre dos otros puntos. En este caso queremos saber si q esta entre p y r (up y low)
  def on_segment(self,p, tol = 0.0001):
    p1 = self.up
    p2 = self.low

    if (dist(p1,p) + dist(p2,p)) - dist(p1,p2) < tol:
      return True
    return False

  def get_point_on_height(self, h): #Regresa el punto del segmento que esta a altura h
    # Se asume que el segmento no es horizontal
    if h > self.up.y or self.low.y > h: # Si la sweepline no esta en el segmento
      return None

    Ay = self.up.y
    By = self.low.y

    Ax = self.up.x
    Bx = self.low.x

    if Ay == By: # Caso particular donde el segmento es horizontal
      return self.up

    t = (h - Ay)/(By-Ay)

    x_coord = Ax*(1-t) + Bx*t

    return Point(x_coord, h)

  # Considerar a los segmentos horizontales como los mayores
  def __lt__(self, other):
    A = self.get_point_on_height(height_sweepline)
    B = other.get_point_on_height(height_sweepline)

    return A < B

  def __gt__(self, other):
    A = self.get_point_on_height(height_sweepline)
    B = other.get_point_on_height(height_sweepline)

    return A > B

  def __eq__(self, other):
    A = self.get_point_on_height(height_sweepline)
    B = other.get_point_on_height(height_sweepline)

    return A == B

def print_ids_segmentos(S):
  string ="["
  n = len(S)
  for i in range(n):
    if i == n-1:
      string += f"{S[i].id}"
    else:
      string += f"{S[i].id}, "
  string += "]"
  print(string)

# Puntos
class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y

  def print(self):
    print(f"({self.x}, {self.y})")

  def __lt__(self, other):
    if self.y == other.y:
      return self.x < other.x
    return self.y > other.y

  def __gt__(self, other):
    if self.y == other.y:
      return self.x > other.x
    return self.y < other.y

  def __eq__(self, other):
    return (self.x == other.x) and (self.y == other.y)

def dist(p,q):
  return ((p.x - q.x)**2 + (p.y - q.y)**2)**(1/2)


# Eventos
class Event_Point: # Guardamos el punto del evento, e informacion sobre en que segmentos esta y que posicion ocupa
  def __init__(self, p, info):
    self.p = p
    self.info = info

  def print(self):
    self.p.print()
    print(self.info)

  def separate(self):
    return self.p, self.info

  def __lt__(self, other):
    return self.p < other.p

  def __gt__(self, other):
    return self.p > other.p

  def __eq__(self, other):
    return self.p == other.p

"""# Funciones auxiliares

Declaramos funciones que serán útiles para el desarrollo del algoritmo
"""

def A_minus_B(A,B): # Regresa el conjunto A\B
  return [elemento for elemento in A if elemento not in B]

def buscar_vecinos(p, posibles_vecinos):
  # Buscamos a los vecinos
  sl = None # Para guardar el vecino izquierdo
  l_dist = np.inf # Distancia minima desde p al vecino izquierdo
  sr = None # Para guardar el vecino derecho
  r_dist = np.inf # Distancia minima desde p al vecino derecho

  print("Buscamos los posibles vecinos para:")
  p.print()
  #print("Los posibles vecinos son:")
  print_ids_segmentos(posibles_vecinos)
  for s in posibles_vecinos:
    print(f"Evaluando al segmento {s.id}")
    punto = s.get_point_on_height(p.y) # Tomamos el punto de s que esta a la altura de p
    punto.print()
    dif = p.x - punto.x # Diferencia desde el punto a p

    if dif > 0: # Si esta a la izquierda del punto
      if dif < l_dist: # Si es el vecino mas cercano
        sl = s
        l_dist = dif
    elif dif < 0: # Si esta a la derecha del punto
      if -dif < r_dist: # Si es el vecino mas cercano
        sr = s
        r_dist = -dif

  return sl, l_dist, sr, r_dist

def leftmost(Segmentos):
  #Segmentos.sort()
  return Segmentos[0]

def rightmost(Segmentos):
  #Segmentos.sort()
  return Segmentos[-1]

# Considerando el segmento p -> q, nos indica en que lado esta r
def orientation(p,q,r):
  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
  if val == 0:
    #print("En segmento")
    return 0
  elif val > 0:
    #print("Derecha")
    return 1
  else:
    #print("Izquierda")
    return -1

# Funcion para determinar si dos segmentos se intersectan
def do_intersect(s1, s2):
  # Obtenemos los puntos de cada segmento
  p1, q1 = s1.up, s1.low
  p2, q2 = s2.up, s2.low

  #Recordemos que la intersección es solo válida si los dos segmentos se
  # intersectan en un solo punto que esta estrictamente dentro de ambos segmentos

  #Obtenemos las orientaciones de los puntos de cada segmento con el otro segmento
  o1 = orientation(p1, q1, p2)
  o2 = orientation(p1, q1, q2)
  o3 = orientation(p2, q2, p1)
  o4 = orientation(p2, q2, q1)

  # Ahora, consideraremos los siguientes casos para determinar si hay una interseccion

  # Si se cumple que ambos segmento forman una cruz
  if (o1 != o2 and o3 != o4):
    return True
  return False

# Funcion para obtener el punto de interseccion de dos segmentos
# Se asume que si se intersectan
def get_intersection(s1, s2):
  x1, y1 = s1.up.x, s1.up.y # Coordenadas de p1 de s1
  x2, y2 = s1.low.x, s1.low.y # Coordenadas de p2 de s1
  x3, y3 = s2.up.x, s2.up.y # Coordenadas de p1 de s2
  x4, y4 = s2.low.x, s2.low.y # Coordenadas de p2 de s2

  denom = ((x1 - x2) * (y3 - y4)) - ((y1 - y2) * (x3 - x4))

  # Encuentra el punto de intersección
  px = (((x1 * y2) - (y1 * x2)) * (x3 - x4) - (x1 - x2) * ((x3 * y4) - (y3 * x4))) / denom
  py = (((x1 * y2) - (y1 * x2)) * (y3 - y4) - (y1 - y2) * ((x3 * y4) - (y3 * x4))) / denom

  return Point(px, py)


def generate_random_segments(n):
  S = []
  for i in range(n):
    x1 = random.uniform(0, 10)
    y1 = random.uniform(0, 10)
    x2 = random.uniform(0, 10)
    y2 = random.uniform(0, 10)

    S.append(Segment(Point(x1, y1), Point(x2, y2), i))
  return S

def print_segmentos(S):
  for s in S:
    print(f"Segmento {s.id}: up({s.up.x},{s.up.y}) low({s.low.x},{s.low.y})")

# Funcion que imprime un conjunto se segmentos
def plot_segmentos(S, I = None):
  plt.figure(figsize=(8, 8))

  for seg in S:
    mid_x = (seg.up.x + seg.low.x)/2
    mid_y = (seg.up.y + seg.low.y)/2
    label = f"s_{seg.id}"
    #l1 = f"[{seg.id}]up"
    #l2 = f"[{seg.id}]low"
    plt.plot([seg.up.x, seg.low.x], [seg.up.y, seg.low.y], color='blue')
    plt.scatter([seg.up.x, seg.low.x], [seg.up.y, seg.low.y], color='red')
    plt.text(mid_x, mid_y, label, fontsize=12, ha='center', va='center')
    #plt.text(seg.up.x, seg.up.y, l1, fontsize=12, ha='center', va='center')
    #plt.text(seg.low.x, seg.low.y, l2, fontsize=12, ha='center', va='center')

  if I != None:
    for p in I:
      plt.scatter(p.x, p.y, color='magenta', s = 100)

  plt.xlabel('X')
  plt.ylabel('Y')
  plt.title('Conjunto de Segmentos')
  plt.grid(True)
  plt.axis('equal')
  plt.show()

"""# Algoritmo: Line Segment Intersection"""

def Insert_Event_Point(Tree, e_p): # Insertamos el evento e_p en el arbol Tree
  p, info = e_p.separate()

  # Verificamos si ya hay un nodo del evento e_p
  #e_p.print()
  node = Tree.search(e_p)
  if node == Tree.NULL: # Si no hay tal nodo
    Tree.insert(e_p) # Insertamos el evento sin mas
  else: # Si ya hay un nodo
    #print(f"---->")
    #node.key.print()
    Tree.delete_node(node.val) # Lo borramos
    info = node.val.info + info # Agregamos la nueva información a la ya existente
    new_e_p = Event_Point(e_p,info) # Creamos un nuevo event point con la info actualizada
    Tree.insert(new_e_p)


def Find_Intersections(S, epsilon = 0.00001):
  global height_sweepline
  height_sweepline = np.inf # Comenzamos con la sweepline en el infinito, para luego bajarla por los event points

  # Declaramos los RBT para Q y T
  Q = RBTree()
  T = RBTree()

  # Declaramos un arreglo para agregar las intersecciones
  intersecciones = []

  # Analizamos todos los segmentos para buscar los event points
  for i, seg in enumerate(S):
    u = seg.up
    l = seg.low
    Insert_Event_Point(Q, Event_Point(u, [[i, "u"]]))
    Insert_Event_Point(Q, Event_Point(l, [[i, "l"]]))

  while not Q.is_empty():# Mientras hayan eventos
    evento = Q.pop_minimum()
    #evento = Q.minimum(Q.root)
    p, info = evento.val.separate()
    height_sweepline = p.y
    print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print("Manejaremos al evento:")
    p.print()
    print("\n")
    Handle_Event_Point(S, Q, T, p, info, intersecciones, epsilon)
    #Q.delete_node(evento.val)

  print(f"ESTADO FINAL. SE ENCONTRARON {len(intersecciones)} INTERSECCIONES")
  return intersecciones

# Determinamos si sl, sr se intersectan, y si entra en Q
def find_new_event(Q, sl,sr,p):
  #print(f"----------> {sr}")

  if do_intersect(sl, sr): # Si sl,sr se intersectan
    interseccion = get_intersection(sl, sr) # Obtenemos la interseccion
    if (interseccion.y < height_sweepline) or (interseccion.y == height_sweepline and interseccion.x >= p.x): # Si la interseccion esta debajo de la sweepline (o en ella y a la derecha de p)
      # Obtenemos los indices de los segmentos que se intersectan
      id_sl = sl.id
      id_sr = sr.id
      evento = Event_Point(interseccion, [[id_sl,"c"],[id_sr,"c"]])
      node_interseccion = Q.search(evento)
      if node_interseccion == Q.NULL: # Si la interseccion (evento) aun no esta en Q
        Insert_Event_Point(Q, evento)
        print(f"////////  SE DETECTO UN EVENTO (INTERSECCION entre {sl.id} y {sr.id})  ////////")
        interseccion.print()
        print("\n")



def Handle_Event_Point(S, Q, T, p, info, intersecciones, epsilon): # Analizamos el evento en (p, info)
  global height_sweepline
  U = [] # Conjunto de segmentos que tienen a p como upper
  L = [] # Conjunto de segmentos que tienen a u como lower
  C = [] # Conjunto de segmentos encontrados que tienen a p en su interior

  for data in info:
    if data[1] == "u":
      U.append(S[data[0]])

  segmentos_actuales = T.inorder_transversal_keys() # Optenemos los segmentos actuales en T inorder

  # Evaluamos a p en los segmentos, y determinamos como apregamos
  for s in segmentos_actuales:
    #print("Evaluando")
    #s.print()
    if p == s.low:
      L.append(s)
      #print("Es L")
    elif s.on_segment(p):
      C.append(s)
      #print("Es C")

  ULC = U+L+C

  if len(ULC) > 1: # Si U( L(p), U(p), C(p) ) tiene mas de un segmento
    print("////////  SE AGREGO UNA INTERSECCION POR ULC  ////////")
    p.print()
    print("\n")
    intersecciones.append(p) # Reportamos a p como una interseccion

  print("El estado de T ANTES es:")
  print_ids_segmentos(T.inorder_transversal_keys())
  #T.state()
  print("\n")

  # Para eliminar a los segmento de LC, subimos la sweepline una cantidad epsilon
  height_sweepline += epsilon
  print("Buscamos eliminar a:")
  # Eliminamos de T a los segmentos en L(p) u C(p)
  LC = L+C
  for s in LC:
    print(f"---[{s.id}]---")
    print(f"Estado actual de T:")
    print_ids_segmentos(T.inorder_transversal_keys())
    #print(f"Raiz actual: {T.root.val.id}")
    node = T.search(s)
    if node != T.NULL:
      print("Se elimino el nodo")
    else:
      print("No se pudo eliminar el nodo    XXXXXXX  ERROR  XXXXXXX")
    print("\n")

    T.delete_node(s)
  height_sweepline -= epsilon # Restauramos la sweepline


  # Insertamos los elementos de U(p) u C(P) en T (bajamos la sweepline una cantidad epsilon)
  UC = U+C
  height_sweepline -= epsilon
  print("\nBuscamos insertar a")
  print_ids_segmentos(UC)
  for s in UC:
    #print("Buscamos insertar a")
    #s.print()
    T.insert(s)
  height_sweepline += epsilon # Restauramos la sweepline

  segmentos_in_T = T.inorder_transversal_keys() # Obtenemos los segmentos actuales en T, seran utiles mas adelante
  print("\nEl estado de T DESPUES es:")
  print_ids_segmentos(segmentos_in_T)
  print("\n")

  # Si U(p) u C(p) esta vacia
  # Esto se puede interpretar como que p no es un upper o interseccion. Y debido a que es un evento, debe ser un low
  if len(UC) == 0:
    # Buscamos a los vecinos izquierdo y derecho del punto p que se encuentren en T

    posibles_vecinos = A_minus_B(segmentos_in_T, UC) # Ignoramos los segmentos en los que p se encuentra (como endpoint o dentro)

    sl, dl, sr, dr = buscar_vecinos(p, posibles_vecinos) # Obtenemos los vecinos de p (si existen)

    if dl != np.inf and dr != np.inf: # Si los vecinos existen
      print("Vecino Izquierdo y Vecino Derecho")
      print(sl.id, sr.id)
      find_new_event(Q, sl, sr, p)

  else:
    print("Iniciaremos proceso de buscar vecinos para LEFTMOST Y RIGHTMOST")
    print("UC:")
    # Obtenemos a UC segun el orden usado al insertar
    height_sweepline -= epsilon
    UC.sort()
    height_sweepline += epsilon

    print_ids_segmentos(UC)
    print("T:")
    print_ids_segmentos(T.inorder_transversal_keys())

    s_ = leftmost(UC)
    print(f"LEFTMOST: \t{s_.id}")
    id_sl = T.vecino_izquierdo_idx(s_.id)
    if id_sl != -1: # Si el vecino existe
      sl = segmentos_in_T[id_sl]
      print(f"Vecino LEFT:\t{sl.id}")
      find_new_event(Q, sl, s_, p)
    else:
      print(f"Vecino LEFT:\t{-1}")
    print("\n")

    s__ = rightmost(UC)
    print(f"RIGHTMOST: \t{s__.id}")
    id_sr = T.vecino_derecho_idx(s__.id)
    if id_sr != -1: # Si el vecino existe
      sr = segmentos_in_T[id_sr]
      print(f"Vecino RIGHT:\t{sr.id}")
      find_new_event(Q, s__, sr, p)
    else:
      print(f"Vecino RIGHT:\t{-1}")

"""# Pruebas del algoritmo"""

S = generate_random_segments(5)

plot_segmentos(S)

intersecciones = Find_Intersections(S)
plot_segmentos(S, I=intersecciones)